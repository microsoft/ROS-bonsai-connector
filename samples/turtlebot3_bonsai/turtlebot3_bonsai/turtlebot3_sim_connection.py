from typing import Dict
import os
import json
import time
import argparse

# ROS
from rclpy.utilities import remove_ros_args
from std_srvs.srv import Empty
from ament_index_python.packages import get_package_share_directory
from gazebo_msgs.srv import SpawnEntity, DeleteEntity

# import Microsoft Bonsai dependencies
from microsoft_bonsai_api.simulator.client import BonsaiClient, BonsaiClientConfig
from microsoft_bonsai_api.simulator.generated.models import (
    SimulatorInterface,
    SimulatorState,
    SimulatorSessionResponse,
)

from azure.core.exceptions import HttpResponseError

from turtlebot3_bonsai.turtlebot3_bonsai_connection import TurtleBot3BonsaiConnection

NODE_NAME = "turtlebot3_sim_connection"
SIM_NAME = "turtlebot3_bonsai"
ROBOT_NAME = "turtlebot"

class SimulatorConnection(TurtleBot3BonsaiConnection):
    def __init__(self, package, config_file, pose_x, pose_y, pose_z, world):
        # Calls Node.__init__('listener')
        super().__init__(NODE_NAME)

        # Gazebo client calls
        self.reset_client = self.create_client(Empty, "/reset_world")
        
        while not self.reset_client.wait_for_service(timeout_sec=5.0):
            self.get_logger().info('service not available, waiting again...')
        self.spawn_client = self.create_client(SpawnEntity, "/spawn_entity")
        # self.remove_client = self.create_client(DeleteEntity, "/delete_entity")
        
        while not self.spawn_client.wait_for_service(timeout_sec=5.0):
            self.get_logger().info('service not available, waiting again...')

        # LOAD BONSAI CONFIG
        with open(os.path.join(get_package_share_directory(package), config_file)) as file:
            self.interface = json.load(file)

        self.iteration = 0
        self.episode = 0
        self.sim_delay = 0.0
        self.episode_config = {}
        self.done = False

        self.event_timer = self.create_timer(
            0.250,  # unit: s
            self.event_callback)
        
        # Get path to the turtlebot3
        self.sdf = os.path.join(
            get_package_share_directory("turtlebot3_gazebo"), "models",
            "turtlebot3_burger", "model.sdf")
        
        # Spawn turtlebot
        self.get_logger().info("Spawning turtlebot3 at [{}, {}, {}] in world '{}'".
                               format(pose_x, pose_y, pose_z, world))
        self.spawn_turtlebot(pose_x, 
                             pose_y, 
                             pose_z)

    def step(self, actions: dict):
        """
        Function executed each time step.
        Here we get actions from Bonsai, execute them in a time step in the simulator,
        and retrieve the observations generated by that action.
        :param action:
        """
        # PAUSE SIMULATION

        # PARSE ACTIONS FROM BONSAI
        for action, value in actions.items():
            if action == "input_linear_velocity_x": 
                self.cmd_vel_data.linear.x = value * self.MAX_LINEAR_VEL_BURGER
            elif action == "input_angular_velocity_z":
                self.cmd_vel_data.angular.z = value * self.MAX_ANGULAR_VEL_BURGER

        # Command Turtlebot3
        self.cmd_vel_pub.publish(self.cmd_vel_data)

        # UNPAUSE SIMULATION
        time.sleep(0.1)  # Wait for some time to execute sim state change
        
        # RETRIEVE OBSERVATIONS FROM SIMULATION
        self.get_odom_state_data()
        self.get_imu_state_data()
        self.get_laser_scan_state_data()

        # end of step

    def reset(self):
        self.reset_sim()
        self.step({})
        self.event_timer.reset()
        
        # Sample range is the arc (centered forward for turtlebot) of the lidar
        # that will be considered for learning.
        # Defaults to 360
        if "sample_range" in self.episode_config:
            self.state["sample_range"] = self.episode_config["sample_range"]
        else:
            self.state["sample_range"] = 360

        # Not necessary for learning, but may be used as an input for learning objectives
        if "goal_pose_x" in self.episode_config:
            self.state["goal_pose_x"] = self.episode_config["goal_pose_x"]
        if "goal_pose_y" in self.episode_config:
            self.state["goal_pose_y"] = self.episode_config["goal_pose_y"]

    def reset_sim(self):
        reset = Empty.Request()
        self.reset_client.call_async(reset)

        time.sleep(0.3)

    def spawn_turtlebot(self, x, y, z):
        spawn = SpawnEntity.Request()
        spawn.xml = open(self.sdf, 'r').read()
        spawn.name = ROBOT_NAME
        spawn.robot_namespace = ""
        spawn.initial_pose.position.x = x
        spawn.initial_pose.position.y = y
        spawn.initial_pose.position.z = z

        self.get_logger().info("Sending service request to `/spawn_entity`")
        self.spawn_client.call_async(spawn)

        time.sleep(0.3)

    def get_episode_config(self, config: dict):
        self.episode_config = config
        self.get_logger().debug(
            "Episode config loaded:\n{}".format(json.dumps(config, indent=2))
        )

    def halted(self) -> bool:
        """Halt current episode. Note, this should only return True if the simulator has reached an unexpected state.
        Returns
        -------
        bool
            Whether to terminate current episode
        """
        return False

    def get_event(self):

        sim_state = SimulatorState(
            sequence_id=self.sequence_id, state=self.state, halted=self.halted(),
        )

        self.get_logger().debug(
            "SimulatorState: \n{}".format(json.dumps(str(sim_state.state), indent=2))
        )

        try:
            event = self.client.session.advance(
                workspace_name=self.config_client.workspace,
                session_id=self.registered_session.session_id,
                body=sim_state,
            )
            self.sequence_id = event.sequence_id
            # self.get_logger().info(
            #     "[{}] Last Event: {}".format(time.strftime("%H:%M:%S"), event.type)
            # )
        except HttpResponseError as ex:
            self.get_logger().error(
                "HttpResponseError in Advance: StatusCode: {}, Error: {}, Exception: {}".format(
                    ex.status_code, ex.error.message, ex
                )
            )
            # This can happen in network connectivity issue, though SDK has retry logic, but even after that request may fail,
            # if your network has some issue, or sim session at platform is going away..
            # So let's re-register sim-session and get a new session and continue iterating. :-)
            self.registered_session, self.sequence_id = self.CreateSession(self.registration_info, self)
        except Exception as err:
            self.get_logger().error("Unexpected error in Advance: {}".format(err))
            # Ideally this shouldn't happen, but for very long-running sims It can happen with various reasons, let's re-register sim & Move on.
            # If possible try to notify Bonsai team to see, if this is platform issue and can be fixed.
            self.registered_session, self.sequence_id = self.CreateSession(self.registration_info, self)

        return event

    def event_callback(self):
        event = self.get_event()

        # Event loop
        if event.type == "Idle":
            time.sleep(event.idle.callback_time)
            self.get_logger().info("Idling...")

        elif event.type == "EpisodeStart":
            self.episode += 1
            self.get_logger().info("Episode {} Starting...".format(self.episode))
            config = event.episode_start.config

            if config is None:
                raise ValueError("No episode start config received from Bonsai")

            self.get_episode_config(config)
            self.reset()

        elif event.type == "EpisodeStep":
            self.iteration += 1
            self.step(event.episode_step.action)

        elif event.type == "EpisodeFinish":
            self.get_logger().info("Episode {} Finishing...".format(self.episode))
            self.iteration = 0

        elif event.type == "Unregister":
            self.get_logger().info(
                "Simulator Session unregistered by platform because {}".format(
                    event.unregister.details
                )
            )

    def register_simulator(self):

        # Get keys to connect to Bonsai Workspace
        try:
            self.workspace = os.environ["SIM_WORKSPACE"]
            self.accesskey = os.environ["SIM_ACCESS_KEY"]
        except:
            raise IndexError(
                f"Workspace or access key not set or found. Use --config-setup for help setting up."
            )

        # Configure client to interact with Bonsai service
        self.config_client = BonsaiClientConfig()
        self.client = BonsaiClient(self.config_client)

        # Create simulator session and init sequence id
        self.registration_info = SimulatorInterface(
            name=SIM_NAME,
            timeout=self.interface["timeout"],
            simulator_context=self.config_client.simulator_context,
            description=self.interface["description"],
        )

        self.registered_session, self.sequence_id = self.CreateSession(self.registration_info)

    def CreateSession(
        self,
        registration_info: SimulatorInterface
    ):
        """Creates a new Simulator Session and returns new session, sequenceId
        """

        try:
            self.get_logger().info(
                "config: {}, {}".format(self.config_client.server, self.config_client.workspace)
            )
            registered_session: SimulatorSessionResponse = self.client.session.create(
                workspace_name=self.config_client.workspace, body=registration_info
            )
            self.get_logger().info("Registered simulator. {}".format(registered_session.session_id))

            return registered_session, 1
        except HttpResponseError as ex:
            self.get_logger().info(
                "HttpResponseError in Registering session: StatusCode: {}, Error: {}, Exception: {}".format(
                    ex.status_code, ex.error.message, ex
                )
            )
            raise ex
        except Exception as ex:
            self.get_logger().error(
                "UnExpected error: {}, Most likely, it's some network connectivity issue, make sure you are able to reach bonsai platform from your network.".format(
                    ex
                )
            )
        raise ex



